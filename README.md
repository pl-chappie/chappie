# Chappie Overview #

`chappie` is a fine-grained energy profiler for multi-threaded Java applications.
Below is an excerpt from our paper abstract about this work's motivation:

 > Energy accounting is a fundamental problem in energy management, defined as attributing global energy consumption to individual components of interest. In this paper, we take on this problem at the application level, where the components for accounting are **application logical units**, such as methods, classes, and packages. Given a Java application, our novel runtime system `chappie` produces an **energy footprint**, i.e., the relative energy consumption of all programming abstraction units within the application.

 > The design of `chappie` is unique in several dimensions. First, relative to targeted energy profiling where the profiler determines the energy consumption of a pre-defined application logical unit, e.g., a specific method, `chappie` is **total**: the energy footprint encompasses all methods within an application. Second, `chappie` is **concurrency aware**: energy attribution is fully aware of the multi-threaded behavior of Java applications, including JVM bookkeeping threads. Third, `chappie` is an embodiment of a novel philosophy for application-level energy accounting and profiling, which states that the accounting run should preserve the **temporal** phased power behavior of the application, and the **spatial** power distribution among the underlying hardware system. We term this important property as **calmness**. Against state-of-the-art DaCapo benchmarks, we show that the energy footprint generated by `chappie` is precise while incurring negligible overhead. In addition, all results are produced with a high degree of calmness.

 # Experiment reproduction: Docker-based execution #

 Our publication data can be reproduced using a docker image. You can either run the image from docker hub:

 ```bash
 docker run --privileged --cap-add=ALL -it -v /dev:/dev -v /lib/modules:/lib/modules timurbey/chappie-fse20:1.0
 ```

 or build and run the provided `Dockerfile`:

 ```bash
 docker build -t chappie-fse20 .
 docker run --privileged --cap-add=ALL -it -v /dev:/dev -v /lib/modules:/lib/modules timurbey/chappie-fse20:1.0
 ```

 After execution finishes, output data can be found at `./chappie/chappie-data` inside the container.

 **NOTE**: The data reported in the paper was produced through an evaluation with the system described below. As energy consumption varies from system to system, e.g., the number of cores, the OS schedulers, the JVM runtime behavior, etc., a reproduction on a different system may not produce identical results as we reported in the paper. Specifically, `chappie` requires the use of [RAPL](https://en.wikipedia.org/wiki/Perf_(Linux)#RAPL), which only works on Intel cpus:

  > - Dual socket Intel E5-2630 v4 2.20 GHz (20 cores)
  > - Hyper threading enabled
  > - 64 GB DDR4 RAM
  > - Debian 4.9 (linux kernel 4.9)
  > - Debian default `powersave` governor
  > - Java 11 Hotspot VM build 11.0.2+9-LTS

# Experiment reproduction: Building from source #

If you prefer to build `chappie` from source, please follow the instructions below:

## Building ##

`chappie` requires the following to build and run:

```bash
apt-get install -y git openjdk-11-jdk libjna-jni maven ant make python3 python3-pip kmod msr-tools msrtool wget
pip3 install numpy scipy pandas tqdm matplotlib seaborn
```

Once everything is installed, `chappie` can be built from the top-level with:

```bash
cd vendor/jlibc && mvn package && cd ../..
cd vendor/async-profiler && make && cd ../..
cd src/java/jrapl-port && make && cd ../..
ant deps && ant jar
```

To reproduced the FSE experiments as described in the pre-built environment steps, you will need to build the dacapo wrapper:

```bash
cd wrapper && ant deps && ant jar && cd ..
```

## Execution ##

Once the wrapper is built, the entire experiment can be run with:

```bash
cd chappie && ./fse2020/run-experiments.sh
```

This will produce the same output as the docker image above at `./chappie/chappie-data`

**NOTE**: Because of [RAPL](https://en.wikipedia.org/wiki/Perf_(Linux)#RAPL), you will need `su` or `sudo` access to produce energy footprints with `chappie`.

# Profiling arbitrary applications #

To produce an energy footprint of other applications beyond the DaCapo suite, `chappie` is endowed with a public API.

## Step 1: Implement a wrapper ##

A simple way to integrate `chappie` is to build a wrapper around your application.

```java
import chappie.Chaperone;

public class FooWrapper {
  public static void main() {
    Chaperone chappie = new Chaperone();
    chappie.start();

    // program body

    chappie.stop();
  }
}
```

When `stop` is called, `chappie` will dump all collected raw data to disk.

## Step 2: Compile the wrapper ##

The implemented wrapper needs to be compiled into a `.class` or `.jar` for execution with `java`. Unless you have many dependencies, `javac` (and maybe `jar`) should be sufficient.

## Step 3: Bootstrapping the profiler ##

The profiler can be bootstrapped using the following command. `chappie.sh`, as a script, involves the execution of `java`. If your application has additional arguments being fed to `java`, they should be listed as `foo_arg_0`, etc.:

```bash
./chappie.sh -cp foo-wrapper.jar:foo-dependencies FooWrapper foo_arg_0 foo_arg_1 ...
```

The above script will produce a `chappie-logs` directory.

## Step 4: Analyzing the data ##

Collected data can be analyzed using

```bash
  ./scripts/analysis.sh --work-directory ./chappie-logs
```

which produces summaries and plots for the profiled application.
