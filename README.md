# Chappie Overview #

`chappie` is a fine-grained energy profiler for multi-threaded Java applications.
Below is an excerpt from our paper abstract about this work's motivation:

 > Energy accounting is a fundamental problem in energy management, defined as attributing global energy consumption to individual components of interest. In this paper, we take on this problem at the application level, where the components for accounting are **application logical units**, such as methods, classes, and packages. Given a Java application, our novel runtime system `chappie` produces an **energy footprint**, i.e., the relative energy consumption of all programming abstraction units within the application.

 > The design of `chappie` is unique in several dimensions. First, relative to targeted energy profiling where the profiler determines the energy consumption of a pre-defined application logical unit, e.g., a specific method, `chappie` is **total**: the energy footprint encompasses all methods within an application. Second, `chappie` is **concurrency aware**: energy attribution is fully aware of the multi-threaded behavior of Java applications, including JVM bookkeeping threads. Third, `chappie` is an embodiment of a novel philosophy for application-level energy accounting and profiling, which states that the accounting run should preserve the **temporal** phased power behavior of the application, and the **spatial** power distribution among the underlying hardware system. We term this important property as **calmness**. Against state-of-the-art DaCapo benchmarks, we show that the energy footprint generated by `chappie` is precise while incurring negligible overhead. In addition, all results are produced with a high degree of calmness.

# Experiment reproduction: Docker-based execution #

Our publication data can be reproduced using [this docker image](); after the image finishes, the output data can be found at `./chappie-data`.

**NOTE**: The data reported in the paper was produced through an evaluation with the system described below. As energy consumption varies from system to system, e.g., the number of cores, the OS schedulers, the JVM runtime behavior, etc., a reproduction on a different system may not produce identical results as we reported in the paper:

 > - Dual socket Intel E5-2630 v4 2.20 GHz (20 cores)
 > - Hyper threading enabled
 > - 64 GB DDR4 RAM
 > - Debian 4.9 (linux kernel 4.9)
 > - Debian default `powersave` governor
 > - Java 11 Hotspot VM build 11.0.2+9-LTS

# Experiment reproduction: Building from source #

If you prefer to build `chappie` from source, please follow the instructions below:

## Building ##

`chappie` requires the following to build and run:

`apt-get install -y git openjdk-11-jdk libjna-jni maven ant make python3 python3-pip kmod msr-tools msrtool`

Once everything is installed, `chappie` can be built with:

```bash
cd chappie/vendor/jlibc && mvn package
cd chappie/vendor/async-profiler && make
cd chappie/src/java/jrapl-port && make
ant deps && ant jar
```

To reproduced the FSE experiments as described in the pre-built environment steps, you will need to build the dacapo wrapper:

```bash
cd chappie/wrapper && ant deps && ant jar
cd chappie/wrapper/jar && java -jar dacapo-evaluation-git.jar --extdata-install .
```

Once the wrapper is built, the entire experiment can be run with:

```bash
sudo ./fse2020/run-experiments.sh path/to/data
```

# Profiling arbitrary applications #

To produce an energy footprint of other applications beyond the DaCapo suite, `chappie` is endowed with a public API.

To produce an energy footprint of other applications beyond the DaCapo suite, `chappie` is endowed with a public API.

## Step 1: Implement a wrapper ##

A simple way to integrate `chappie` is to build a wrapper around your application.

```java
import chappie.Chaperone;

public class FooWrapper {
  public static void main() {
    Chaperone chappie = new Chaperone();
    chappie.start();

    // program body

    chappie.stop();
  }
}
```

When `stop` is called, `chappie` will dump all collected raw data to disk.

## Step 2: Compile wrapper ##



## Step 3: Bootstrapping the profiler ##

The profiler can be bootstrapped using the following command. `chappie.sh`, as a script, involves the execution of `java`. If your application has additional arguments being fed to `java`, they should be listed as `foo_arg_0`, etc.:

```bash
./chappie.sh -cp foo-wrapper.jar FooWrapper foo_arg_0 foo_arg_1 ...
```

## Step 4: Analyzing the data ##

Collected data can be analyzed using `./scripts/analysis.sh --work-directory $work_dir`, producing summaries and plots for the application.

## Additional options ##

The data target location can be changed using `-d/--work-directory path/to/data`; the default location is `./chappie-logs`

`./chappie.sh` passes '-Dargs' to the Java runtime as well as providing arguments for setting internal behavior:
 - `rate`: base sampling epoch rate in millis; `chappie` maintains bookkeeping using epochs to simplify data processing. A rate of 0 will only collect calmness data.
 - `vm/os/freq/rapl`: epoch sampling factor for data collection; our implementation collects data sequentially to minimize race conditions. The collection is The profiler will collect data every `-Dchappie.rate` * `-Dchappie.<unit>` ms.
 - `trace`: sampling rate for the modified async-profiler in ns; the implementation for this is described in `./vendor/async-profiler/README.md`. The stack trace storage structure requires a periodic flush of the buffer, `chappie` does this every 10 sampling epochs. Make sure the epoch rate and async-profiler rate match to prevent the buffer from filling up.



## Examples ##

A example wrapper for the DaCapo benchmark suite is provided at `./wrapper`. Full experiment implementations are provied at `./fse2020/experiments`
