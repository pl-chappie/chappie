# chappie #

`chappie` is a statistical profiler for Java runtimes that produces application-level energy footprint.
Below is an excerpt from our paper abstract about this work's motivation:

 > Energy accounting is a fundamental problem in energy management, defined as attributing global energy consumption to individual components of interest. In this paper, we take on this problem at the application level, where the components for accounting are **application logical units**, such as methods, classes, and packages. Given a Java application, our novel runtime system `chappie` produces an **energy footprint**, i.e., the relative energy consumption of all programming abstraction units within the application.

<!-- The design of \ourframework{} is unique in several dimensions. First, relative to targeted energy profiling where the profiler determines the energy consumption of a pre-defined application logical unit, e.g., a specific method, \ourframework{} is \emph{total}: the energy footprint encompasses all methods within an application. Second, \ourframework{} is \emph{concurrency-aware}: energy attribution is fully aware of the multi-threaded behavior of Java applications, including JVM bookkeeping threads. Third, \ourframework{} is an embodiment of a novel philosophy for application-level energy accounting and profiling, which states that the accounting run should preserve the \emph{temporal} phased power behavior of the application, and the \emph{spatial} power distribution among the underlying hardware system. We term this important property as \emph{calmness}. Against state-of-the-art DaCapo benchmarks, we show that the energy footprint generated by \ourframework{} is precise while incurring negligible overhead. In addition, all results are produced with a high degree of calmness. -->

# FSE 2020 experiment reproduction #

Our publication data can be reproduced using a pre-built environment provided [here](). Once the environment is setup, the experiments and data can be reproduced with the command:

```bash
sudo ./fse2020/run-experiments.sh path/to/data
```

This will produce a data set similar to the provided data at `./fse2020/data` and validate it within a threshold of `THRESHOLD_VALUE`.

# Building from source #

If you prefer to build `chappie` from source, please follow the instructions below:

**NOTE**: Before building `chappie` there are two technical details that you may want to consider:

 - `chappie` uses [RAPL](https://en.wikipedia.org/wiki/Perf_(Linux)#RAPL), so a Intel system is required to produce profiles.
 - `chappie` has only been tested on Debian 9 so there is no guarantee that it will work on other Linux distros.

## Building ##

`chappie` requires the following build tools:

 - `ant`
 - `java` (works on 8 but is intended for use with 9+)
 - `jni`
 - `make`
 - `maven`

Once all the tools have been installed, `chappie` can be built with:

```bash
# build the dependencies
ant deps
# build the runtime jar
ant jar
```

Once the build is complete, the experiments can be reproduced as described in the pre-built environment steps.

# Public API Usage #

`chappie` is an asynchronous profiler so it can be run in parallel around other logic. The simplest way to use `chappie` is to build a wrapper in your program:

```java
import chappie.Chaperone;

public class FooWrapper {
  public static void main() {
    Chaperone chappie = new Chaperone();
    chappie.start();

    // program body

    chappie.stop();
  }
}
```

When `stop` is called, chappie will dump all collected raw data to disk.

## Profiling ##

A bootstrapping script is provided (`./chappie.sh`) that mimics `java` but also sets up `chappie`'s runtime dependencies:

```bash
./chappie.sh -cp foo-wrapper.jar FooWrapper foo_arg_0
```

The data target location can be changed using `-d/--work-directory path/to/data`; the default location is `./chappie-logs`

`./chappie.sh` passes '-Dargs' to the Java runtime as well as providing arguments for setting internal behavior:
 - `rate`: base epoch rate in millis; `chappie` maintains bookkeeping using epochs to simplify data processing. A rate of 0 will only collect calmness data.
 - `vm/os/freq/rapl`: epoch sampling factor for data collection; our implementation collects data sequentially to minimize race conditions. The collection is The profiler will collect data every `-Dchappie.rate` * `-Dchappie.<unit>` ms.
 - `trace`: sampling rate for the modified async-profiler in ns; the implementation for this is described in `./vendor/async-profiler/README.md`. The stack trace storage structure requires a periodic flush of the buffer. `chappie` flushes the buffer every 10 epochs. Make sure the epoch rate and async-profiler rate match to prevent the buffer from filling up too frequently.

Collected data can be analyzed using `./scripts/analysis.sh $work_dir`, producing summaries and plots for the application.

## Examples ##

A example wrapper for the DaCapo benchmark suite is provided at `./wrapper`. Full experiment implementations are provied at `./fse2020/experiments`
